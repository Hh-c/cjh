## Instant Ray Tracing: The Bounding Interval Hierarchy

[链接](http://ainc.de/Research/BIH.pdf)

本文提出了一种新的光线追踪算法，该算法结合了 BVH 的内存效率和 kd-树的遍历效率。它采用了一种新的全局空间划分启发式算法，比传统的表面积启发式算法评估成本更低。新算法内存占用少，数值精度高，易于实现，并且在大规模和动态场景中表现出高性能。

### 1 Introduction

光线追踪依赖于 ads (acceleration data structure), 但是构建 ads 的时间和内存开销很大, 且目前对于高效构建 ads 还没太多研究. 本文提出了一种层次加速数据结构, 可被高效构建.

### 2 Principles of Accelerating Ray Tracing

原因: 因为最终所有光线和所有物体的交互是不可能高效的, 所以需要加速;

方法:

1. 使用 ads, 获取 ads 有以下两种方法

   (1) 划分包含物体的空间; (2)划分物体列表;

2. 摊销追踪光线集的额外成本

#### 2.1. Partitioning Space

简介: 将空间划分为不相交的体素, 然后枚举与光线相交的体并测试其中的物体

问题: 可能一个物体与多个体素相交, 导致内存占用增大，需要信箱机制来避免同一物体多次相交的问题

##### 2.1.1. Regular Grids

简介: 将空间划分为统一矩形轴对齐体

问题: 

1. 内存: 内存开销没法预先确定. 如果通过栅格化物体来构建数据结构, 会有精度问题; 而栅格化物体的边界框来构建则会增大内存开销.
2. 效率: 遍历空体积元素效率会显著下降,  可使用分层结构 (但层次切换开销大), 或使用其他空间自适应方案解决.

##### 2.1.2. Binary Space Partition

简介:  Binary Space Partition 是一种层次数据结构, 其基本思想是使用任意平面自适应地细分空间，从而克服由空体素引起的规则网格效率问题.

具体实现: 

1. 使用多边形本身确定的平面, 但尚不知道如何高效实现
2. kd-tree 限制划分为仅使用垂直于规范轴的平面

内存问题: 与所有空间划分方案一样，对象可能存在于多个体积元素中, 因此在层次结构的构建过程中，内存管理也是个问题. 即使使用启发式算法在某些情况也不适用, 甚至效果更差

#### 2.2. Partitioning Object Lists

优点: 当划分对象列表时，每个对象最多被引用一次，并且可以预先预测内存需求。且因为每条光线最多与每个对象相交一次，因此不需要 mailbox

缺点: 但是包围对象组的体积很可能会相交

##### 2.2.1. Bounding Volume Hierarchy

简介: 最早在 [Ray Tracing Complex Scenes](https://papers.cumincad.org/data/works/att/67d2.content.pdf) 提出, 常在行业中使用

构建: 有自顶向下, 自底向上的启发式构建算法, 常用最小化所有体素的总体积. 但是这些优化过程都很慢, 且尚不知晓最优方法

优点: 

1. 内存: 内存需求与对象数量成正比, 可以预先确定;
2. 简单: 比空间划分更简单, 因为不用对象-平面相交例程;
3. 稳定: 数组稳定性, 因为使用轴对齐的矩形;

缺点:

1. 性能: 由于体素是无序的 (不像Binary Space Partition是有序的)，因此会导致严重的性能损失;

#### 2.3. Summarizing the State of the Art



### 3 The Bounding Interval Hierarchy

本文提出了一种算法, 同时为静态和动态场景提供了卓越的速度, 具有更高的数值精度, 并允许预先确定内存占用. 它可以被认为是结合了划分对象列表和高效遍历空间分区的优点.

#### 3.1. Data Structure

BIH 核心思想: 只存储两组互相平行的平面 (垂直于 x or y or z). 给定一个包围盒和一个轴，左子节点 L 是将原包围盒沿该轴的最大值替换为第一个平面而得到的 (右子节点 R 类似) (具体见 fig2)

BVH: 传统的 BVH 为每个子节点存储一个完整的轴对齐包围盒



数据结构: BIH节点包含两个裁剪平面 (Clip[]) 和一个指向一对子节点的指针 (Index). Index 最低两位可以表示轴或叶节点. 叶子节点包含一个 32 位指针 (Items)，指向被引用的对象及其总数



#### 3.2. Ray Intersection

求交过程: 用射线与 BIH 求交类似于遍历 BVH。 但因为 BIH 中的子节点在空间上是有序的，所以可以更有效地实现求交。 通过射线方向的符号，可以直接访问离射线原点更近的子节点。 因此，遍历过程几乎与 kd 树相同（如 fig2 所示）。

特点: 

1. 隐式地跳过了空叶子节点 (fig 2d), 也因为不需要存储空叶子节点，节省了存储空间,
2. 体素可以重叠, 所以需要测试堆栈上所有的体积元素，以寻找最近的交点, 找到交点后, 可以剪枝掉那些比当前交点更远的体素对应的分支

#### 3.3. Construction of the Hierarchy

假设已给定分割平面，每个对象根据其主要重叠在分割平面的哪一侧被分类为左侧或右侧。然后，子节点的两个分割平面值分别由左侧对象的最大坐标和右侧对象的最小坐标确定。

##### 3.3.1. A new Global Heuristic

简介: BIH 使用一种非贪婪的启发式算法来确定分割平面

过程: 

1. 沿最长边的中间点对包围盒 (是沿轴对齐的) 进行递归细分, 生成候选平面, 如 fig3a;
2. 如果候选平面位于要细分的体素的包围盒之外，则继续使用体素所在一半的候选平面;
3. 

特点: 分割平面实际上不是内部节点的实际包围盒, 仅由场景的全局包围盒确定。 这是与先前方法的实际区别



##### 3.3.2. Approximate Sorting

简介: BIH 构建过程实际上是一种排序算法, 结构类似于快速排序,  O(nlogn). 使用某种桶排序预处理, 降低排序的常数因子.

过程: 

1. 确定分辨率: 通过场景包围盒大小除以平均对象大小的比例来确定分辨率 (还会结合用户参数)
2. 计数器: 选择每个对象的一个点（例如其包围盒的一个角）, 如果某个网格单元格包含一个点, 则其对应的计数器加一, 最后再将计数器值转换成前缀和 (即 grid cell 的偏移量);
3. 排序: 分配一个全局对象索引数组，并使用每个对象的相同点 (第二步中的点) ，使用前一步的偏移量将对象排序到桶中。对于每个桶，计算它包含的对象的包围盒



##### 3.3.3. Implementation Details

1. 对象划分: 所有对象排序都可以就地完成，无需临时内存管理;
2. 空间划分: 空间划分方案需要处理与体素重叠的对象, 有额外的内存开销;

#### 3.4. Construction on Demand

问题: 原来对整个场景构建完整的 BIH 树, 但是很多节点代表的区域根本不会被光线穿过

解决: 按需构建, 仅在光线遍历的位置（即几何图形“可见”的位置）构建加速结构

